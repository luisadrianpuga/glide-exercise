# Incident Report: SEC-304 – Session Management

## Summary
- Reporter: DevOps Team  
- Priority: High  
- Description: Users could hold multiple active sessions simultaneously. Logging in on a new browser did not invalidate older tokens, allowing shared credentials to stay active indefinitely.

## Impact
- Harder to enforce logouts after credential changes or suspected compromise.
- Lost/stolen session cookies remained valid until expiration, heightening unauthorized access risk.

## Detection
- DevOps observed many concurrent active sessions per user in the `sessions` table and confirmed the API never removed the previous tokens on login.

## Root Cause
1. `authRouter.login` inserted a new session row every time without deleting older sessions for the same user.
2. Signup followed the same pattern (insert only), so any preexisting token (e.g., from QA seeding) stayed valid.

## Resolution
- Updated both signup and login mutations to call `db.delete(sessions).where(eq(sessions.userId, user.id))` before inserting the new token. Only one valid session now exists per user; logging in elsewhere invalidates previous tokens automatically.

## Verification
- Manual testing: logging in from Browser A, then Browser B, confirms the first browser’s cookie becomes invalid (API returns UNAUTHORIZED). Session table now holds a single row per user.

## Lessons Learned
1. Always define session lifecycle requirements (single vs. multi-session) and enforce them explicitly.
2. Monitor session counts per user to detect anomalies.
3. Consider configurable session limits or revocation endpoints for future scalability.
