# Incident Report: VAL-206 – Card Number Validation

## Summary
- Reporter: David Brown  
- Priority: Critical  
- Description: Customers could submit arbitrarily formatted card numbers during account funding, including obviously invalid values. The system only enforced length (16 digits) and a narrow prefix check, so non-existent or malformed cards slipped through.

## Impact
- Users experienced failed or delayed funding transactions after the backend attempted to process invalid cards.
- Support volume increased due to confusion and retrials, hurting trust in the funding flow.

## Detection
- Customer ticket VAL-206 plus internal reproduction showed that entering a future-proof card number like `1111111111111111` was accepted on the form and via API.

## Root Cause
1. `FundingModal` (React) validated only that card numbers were 16 digits beginning with 4 or 5, ignoring other issuers and checksum rules.
2. The `account.fundAccount` TRPC endpoint simply accepted `accountNumber` as a string, so API clients could bypass even the limited UI guard.

## Resolution
- Added shared card helpers (`CARD_PATTERNS`, `passesLuhnCheck`, `validateCardNumber`) in `support-engineer-interview-main/components/FundingModal.tsx`. The form now:
  - Accepts 13–19 digit numbers, detects supported brands (Visa, Mastercard, Amex, Discover), and enforces the Luhn checksum.
  - Normalizes input to digits only and provides descriptive error messages.
- Hardened backend validation in `support-engineer-interview-main/server/routers/account.ts`:
  - Introduced `cardNumberSchema` and a discriminated union for funding sources.
  - Server rejects unsupported card brands, non-digit data, and numbers failing Luhn, and enforces numeric account/routing numbers for ACH.

## Verification
- Manual reasoning: attempts to submit obvious bad numbers (e.g., `1111...`, unsupported prefixes, wrong lengths) now fail immediately on the form and the API. Legit demo cards (e.g., Visa 4111111111111111) succeed.
- Further work suggested: automated unit tests for validators or end-to-end coverage of the funding flow.

## Lessons Learned
1. Critical payment validations must live on both client and server to prevent fraud or bad UX.
2. Define reusable helpers or shared utility modules for card logic to avoid drift.
3. Consider logging validation failures to detect abuse attempts early.
